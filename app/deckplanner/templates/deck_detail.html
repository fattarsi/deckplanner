<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Deck Detail</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<meta name="csrf-token" content="{{ csrf_token }}">
<style>
  html {
    scroll-behavior: smooth;
  }
  .card-column {
    width: 180px;
    position: relative;
  }
  .card-column img {
    width: 100%;
    border-radius: 8px;
    box-shadow: 0 0 8px rgba(0,0,0,.1);
    margin-top: -220px;
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
    z-index: 0;
  }
  .card-column img:first-child {
    margin-top: 0;
  }
  .card-column img:hover ~ img {
    transform: translateY(220px);
  }
  .card-column img:hover {
    z-index: 10;
    transform: scale(1.05);
  }
</style>
</head>
<body class="bg-gray-50 min-h-screen p-6">

<!-- 🏠 Back home -->
<a href="/" id="top" class="text-blue-500 hover:underline">&larr; Back home</a>

<!-- Export Button -->
<button id="export-deck-btn" class="bg-gray-600 text-white px-3 py-1 rounded mt-4">Export Deck</button>

<!-- Export Modal -->
<div id="export-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
  <div class="bg-white p-6 rounded w-[500px] relative">
    <button onclick="closeExportModal()" class="absolute top-2 right-2 text-xl">✕</button>
    <h2 class="text-xl font-bold mb-4">Export Deck</h2>

    <textarea id="export-textarea" class="w-full h-48 border p-2 mb-4" readonly></textarea>

    <div class="flex gap-4 justify-end">
      <button onclick="copyExportText()" class="bg-blue-500 text-white px-4 py-1 rounded">Copy</button>
      <button onclick="downloadExportText()" class="bg-green-600 text-white px-4 py-1 rounded">Download</button>
    </div>
  </div>
</div>


<h1 class="text-2xl font-bold mb-4" id="deck-name">Loading deck...</h1>

<!-- Supertype columns -->
<div id="columns-container" class="flex flex-wrap gap-8"></div>

<!-- Middle section -->
<div class="mt-8 p-6 bg-gray-100 rounded-lg shadow-md grid grid-cols-2 gap-8">
  <!-- Remove column -->
  <div>
    <h3 class="text-red-500 font-bold mb-2 text-right">Remove</h3>
    <div id="remove-column" class="flex flex-col gap-2 items-end min-h-[100px]" data-list="remove"></div>
  </div>

  <!-- Add column -->
  <div>
    <h3 class="text-green-500 font-bold mb-2">Add</h3>
    <div id="add-column" class="flex flex-col gap-2 min-h-[100px]" data-list="add"></div>
  </div>
</div>
  <button id="commit-changes" class="bg-purple-500 text-white px-3 py-1 rounded mt-4">Commit Changes</button>

<!-- Deck Planner -->
<div class="mt-12">
  <button id="toggle-planner" class="bg-blue-500 text-white px-4 py-2 rounded">Open Deck Planner</button>
  <div id="planner-container" class="mt-4 hidden">
    <div id="planner-filters" class="flex flex-wrap gap-4 mb-4 items-center">

    <!-- Search -->
    <input
      type="text"
      id="filter-name"
      placeholder="Search by name"
      class="border rounded px-2 py-1"
    />

    <!-- Supertype -->
    <select id="filter-supertype" class="border rounded px-2 py-1">
      <option value="">All Types</option>
      <option value="Creature">Creature</option>
      <option value="Instant">Instant</option>
      <option value="Sorcery">Sorcery</option>
      <option value="Artifact">Artifact</option>
      <option value="Enchantment">Enchantment</option>
      <option value="Planeswalker">Planeswalker</option>
      <!-- Add more as needed -->
    </select>

    <!-- CMC -->
    <select id="filter-cmc" class="border rounded px-2 py-1">
      <option value="">Any CMC</option>
      <option value="0">0</option>
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5+">5+</option>
    </select>

    <!-- Color Identity -->
    <select id="filter-color" class="border rounded px-2 py-1">
      <option value="">All Colors</option>
      <option value="W">White</option>
      <option value="U">Blue</option>
      <option value="B">Black</option>
      <option value="R">Red</option>
      <option value="G">Green</option>
      <option value="C">Colorless</option>
    </select>
    <!-- Oracle text filter -->
    <input id="filter-oracle-text" class="border rounded px-2 py-1" placeholder="Search oracle text" />

    <!-- Type filter -->
    <input id="filter-type-line" class="border rounded px-2 py-1" placeholder="Search type line" />

  </div>

    <div id="planner-grid" style="display:grid; grid-template-columns:repeat(auto-fit, minmax(11.5rem, 1fr)); gap:2px;"></div>


    <!-- Sentinel div to trigger loading next page -->
    <div id="scroll-sentinel" class="h-1"></div>
  </div>
</div>

<!-- Back to top link -->
<a href="#top" id="back-to-top"
  class="hidden fixed bottom-4 right-4 z-50 bg-blue-500 text-white px-3 py-2 rounded shadow hover:bg-blue-600 transition">
  ↑ Back to top
</a>

<script>
  const plannerGrid = document.getElementById('planner-grid');
  const deckId = "{{ deck_id }}";

  // Attach event listeners
  ['filter-name','filter-supertype','filter-cmc','filter-color','filter-oracle-text', 'filter-type-line'].forEach(id => {
    document.getElementById(id).addEventListener('change', resetAndReloadPlanner);
  });
  ['filter-name', 'filter-oracle-text', 'filter-type-line'].forEach(id => {
    document.getElementById(id).addEventListener('input', debounce(resetAndReloadPlanner, 300)); // optional debounce for search
  });

  function debounce(func, delay) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => func.apply(this, args), delay);
    };
  }
  function resetAndReloadPlanner() {
    // clear current grid
    plannerGrid.innerHTML = '';
    // build new filtered URL
    nextUrl = buildPlannerUrl(`/api/decks/${deckId}/planner`);
    // reset loading flags
    loadingPlanner = false;
    // load first page with filters
    loadPlannerPage(nextUrl);
  }

  const backToTop = document.getElementById('back-to-top');
  document.addEventListener('scroll', () => {
    if (window.scrollY > 400) {
      backToTop.classList.remove('hidden');  // show
    } else {
      backToTop.classList.add('hidden');     // hide
    }
  });
  function getCsrfToken() {
    return document.querySelector('meta[name="csrf-token"]').content;
  }
  new Sortable(document.getElementById('remove-column'), {
    animation: 150,
    group: 'remove',
    draggable: 'img'
  });

  new Sortable(document.getElementById('add-column'), {
    animation: 150,
    group: 'add',
    draggable: 'img'
  });

  function createThumbnail(imgUrl, cardName, list, cardId) {
    const img = document.createElement('img');
    img.src = imgUrl;
    img.title = cardName;
    img.className = 'w-20 h-auto cursor-grab border rounded';
    img.draggable = true;
    img.dataset.list = list;
    img.dataset.id = cardId;
    return img;
  }
  function buildPlannerUrl(baseUrl) {
    const params = new URLSearchParams();
    const name = document.getElementById('filter-name').value;
    const supertype = document.getElementById('filter-supertype').value;
    const cmc = document.getElementById('filter-cmc').value;
    const color = document.getElementById('filter-color').value;
    const oracleText = document.getElementById('filter-oracle-text').value;
    const typeLine = document.getElementById('filter-type-line').value;

    if (name) params.append('search', name);
    if (supertype) params.append('supertype', supertype);
    if (cmc) params.append('cmc', cmc);
    if (color) params.append('color', color);
    if (oracleText) params.append('oracle_text', oracleText);
    if (typeLine) params.append('type_line', typeLine);

    return `${baseUrl}?${params.toString()}`;
  }
  // Handler for clicking a deck card
  document.getElementById('columns-container').addEventListener('click', e => {
    if (e.target.tagName === 'IMG') {
      const card = e.target;
      const cardId = card.dataset.id;
      const removeColumn = document.getElementById('remove-column');

      if (card.classList.contains('border-2')) {
        // Already selected — remove highlight & remove from middle column
        card.classList.remove('border-2', 'border-green-500');

        // Find and remove thumbnail in middle column
        const thumb = removeColumn.querySelector(`img[data-id="${cardId}"]`);
        if (thumb) thumb.remove();
      } else {
        // Highlight this card
        card.classList.add('border-2', 'border-green-500');

        // Create thumbnail in middle column
        const thumb = createThumbnail(card.src, card.title, 'remove', cardId);
        removeColumn.appendChild(thumb);
      }
    }
  });

  // Handler for clicking a planner card
  document.getElementById('planner-grid').addEventListener('click', e => {
    if (e.target.tagName === 'IMG') {
      const card = e.target;
      const cardId = card.dataset.id;
      const addColumn = document.getElementById('add-column');

      if (card.classList.contains('border-2')) {
        // Already selected — remove highlight & thumbnail
        card.classList.remove('border-2', 'border-green-500');
        const thumb = addColumn.querySelector(`img[data-id="${cardId}"]`);
        if (thumb) thumb.remove();
      } else {
        // Highlight
        card.classList.add('border-2', 'border-green-500');

        // Thumbnail
        const thumb = createThumbnail(card.src, card.title, 'add', cardId);
        addColumn.appendChild(thumb);
      }
    }
  });

  document.getElementById('commit-changes').addEventListener('click', async () => {
    const addIds = Array.from(document.getElementById('add-column').children).map(img => img.dataset.id);
    const removeIds = Array.from(document.getElementById('remove-column').children).map(img => img.dataset.id);

    const resp = await fetch(`/api/decks/${deckId}/update_cards/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCsrfToken()
      },
      body: JSON.stringify({ add_ids: addIds, remove_ids: removeIds })
    });

    if (resp.ok) {
      alert('Changes committed successfully.');
      location.reload();
    } else {
      const err = await resp.json();
      alert(`Error: ${JSON.stringify(err)}`);
    }
  });

  async function loadDeck() {
    const resp = await fetch(`/api/decks/${deckId}/`);
    const data = await resp.json();
    document.getElementById('deck-name').textContent = data.name;

    const grouped = {};
    data.cards.forEach(card => {
      const supertype = card.oracle_card.type_line.split(' —')[0];
      if (!grouped[supertype]) grouped[supertype] = [];
      grouped[supertype].push(card);
    });

    const container = document.getElementById('columns-container');

    for (const [typeLine, cards] of Object.entries(grouped)) {
      const columnDiv = document.createElement('div');

      const title = document.createElement('h2');
      title.textContent = typeLine;
      title.className = 'font-semibold text-lg mb-2';
      columnDiv.appendChild(title);

      const column = document.createElement('div');
      column.className = 'card-column';
      columnDiv.appendChild(column);

    const imgUrls = await Promise.all(
      cards.map(async (c) => {
        const imgData = await fetch(`https://api.scryfall.com/cards/${c.oracle_card.id}`).then(r => r.json());
        let imgUrl;

        if (imgData.image_uris) {
          // Single-faced card
          imgUrl = imgData.image_uris.normal;
        } else if (imgData.card_faces && imgData.card_faces.length) {
          // Multi-faced card (e.g. double-faced)
          imgUrl = imgData.card_faces[0].image_uris.normal;
        } else {
          // Fallback image in case of errors
          imgUrl = 'https://via.placeholder.com/200x280?text=No+image';
        }
        // Enable export
        document.getElementById('export-deck-btn').onclick = () => openExportModal(data);

        return { url: imgUrl, name: c.name };
      })
    );


    cards.forEach((card, index) => {
        const img = document.createElement('img');
        img.src = imgUrls[index].url;
        img.title = card.name;
        img.dataset.id = card.id;  // << Add this!
        column.appendChild(img);
      });


      container.appendChild(columnDiv);
    }
  }

  // Planner functionality
  let nextUrl = `/api/decks/{{ deck_id }}/planner`;
  let loadingPlanner = false;

  document.getElementById('toggle-planner').addEventListener('click', async () => {
    const container = document.getElementById('planner-container');
    container.classList.toggle('hidden');
    if (!container.classList.contains('hidden')) {
      // load first page
      if (document.getElementById('planner-grid').children.length === 0) {
        await loadPlannerPage(nextUrl);
      }
    }
  });

  async function loadPlannerPage(url) {
    if (loadingPlanner || !url) return;
    loadingPlanner = true;

    const resp = await fetch(url);
    const data = await resp.json();

    nextUrl = data.next;
    const grid = document.getElementById('planner-grid');

    for (const card of data.results) {
      const imgData = await fetch(`https://api.scryfall.com/cards/${card.oracle_card.id}`).then(r => r.json());
      let imgUrl = imgData.image_uris ? imgData.image_uris.normal : imgData.card_faces[0].image_uris.normal;

      const img = document.createElement('img');
      img.src = imgUrl;
      img.title = card.name;
      img.style.width = '11.5rem';  // custom width
      img.className = 'h-auto transition-transform duration-300 ease-in-out hover:scale-110 cursor-pointer';
      img.dataset.id = card.id;
      grid.appendChild(img);
    }

    loadingPlanner = false;
  }

  // IntersectionObserver to trigger next page
  const sentinel = document.getElementById('scroll-sentinel');
  const observer = new IntersectionObserver(entries => {
    if (entries[0].isIntersecting) {
      //nextUrl = buildPlannerUrl(`/api/decks/${deckId}/planner`);
      loadPlannerPage(nextUrl);
    }
  });
  observer.observe(sentinel);

  function openExportModal(deck) {
    const modal = document.getElementById('export-modal');
    const textarea = document.getElementById('export-textarea');

    // Build export string: "<qty> <name> <collector number>"
    const cardCounts = {};

    deck.cards.forEach(card => {
      const key = `${card.name}|${card.oracle_card.collector_number}`;
      cardCounts[key] = (cardCounts[key] || 0) + 1;
    });

    const lines = Object.entries(cardCounts).map(([key, count]) => {
      const [name, collectorNumber] = key.split('|');
      return `${count} ${name} ${collectorNumber}`;
    });

    textarea.value = lines.join('\n');
    modal.classList.remove('hidden');
  }

  function closeExportModal() {
    document.getElementById('export-modal').classList.add('hidden');
  }

  function copyExportText() {
    const text = document.getElementById('export-textarea').value;
    navigator.clipboard.writeText(text).then(() => {
      alert('Copied to clipboard!');
    });
  }

  function downloadExportText() {
    const text = document.getElementById('export-textarea').value;
    if (!text.endsWith('\n')) text += '\n';
    const deckName = document.getElementById('deck-name').textContent.trim();
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');

    // sanitize filename (remove slashes, colons, etc.)
    const safeName = deckName.replace(/[^a-z0-9-_ ]/gi, '_');

    a.href = url;
    a.download = `${safeName}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  }


  loadDeck();
</script>

</body>
</html>
